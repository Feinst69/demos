---
title: "R Notebook"
output: html_notebook
---


```{r}
library(readxl)
library(tidyverse)
library(ggcorrplot)
library(ggplot2)
library(reshape2)
library(dplyr)
library(compositions)
library(FactoMineR)
library(factoextra)
library(cluster)
```


```{r}
df <- read_excel("data_abs.xlsx")
```


```{r}
head(df)
```



```{r}
# Sélection des colonnes compositionnelles
compositional_data <- df[, c("Ouvrier", "Employe", "PI", "Cadres", "Artisant", "Agri")]

# Appliquer la transformation ILR
ilr_transformed <- ilr(compositional_data)

# Convertir en data frame pour faciliter l'usage
ilr_data <- as.data.frame(ilr_transformed)

# Afficher les premières lignes du résultat
head(ilr_data)
```


```{r}
# Sélectionner les autres variables quantitatives
other_vars <- df[, c("HLM", "Salairemoy", "TxPauv", "NonDiplome", "txcho", "txabs")]

# Combiner les données CLR transformées avec ces autres variables quantitatives
final_df <- cbind(ilr_data, other_vars)

# Afficher les premières lignes du data frame combiné
head(final_df)
```


```{r}
final_df <- scale(final_df,center = TRUE,scale=TRUE)
```



## Mise en place des kmeans

### Etape 4: Détermination du nombre de cluster

### 2 méthodes pour déterminer le nombre de groupe


## Méthode du coude

```{r}
# Détermination du nombre optimal de clusters avec la méthode du coude
fviz_nbclust(final_df, kmeans, method = "wss") + 
    geom_vline(xintercept = 4, linetype = 2) +  # Ajuster le xintercept selon le résultat
    labs(title = "Détermination du Nombre Optimal de Clusters",
         x = "Nombre de Clusters",
         y = "Somme des Carrés Intra-Cluster (WSS)") +
    theme_minimal()
```

Le nombre optimal de cluster avec la méthode du coude est de 4.


## Méthode de silhouette

```{r}
if (!require(purrr)) install.packages("purrr")
library(purrr)

# function to compute average silhouette for k clusters
avg_sil <- function(k) {
  km.res <- kmeans(final_df, centers = k, nstart = 25)
  ss <- silhouette(km.res$cluster, dist(df))
  mean(ss[, 3])
}

# Compute and plot wss for k = 2 to k = 15
k.values <- 2:15

# extract avg silhouette for 2-15 clusters
avg_sil_values <- map_dbl(k.values, avg_sil)

plot(k.values, avg_sil_values,
     type = "b", pch = 19, frame = FALSE, 
     xlab = "Nombre de clusters K",
     ylab = "Silhouettes Moyennes")


fviz_nbclust(final_df, kmeans, method = "silhouette") +
    labs(title = "Détermination du Nombre Optimal de Clusters avec la Méthode de la Silhouette",
         x = "Nombre de Clusters",
         y = "Largeur Moyenne de la Silhouette") +
    theme_minimal()
```

Le nombre optimal avec la méthode de la silhouette est de 2.


```{r}
set.seed(123)  # Pour la reproductibilité
kmeans_result <- kmeans(final_df, centers = 4, nstart = 25)
```


```{r}
fviz_cluster(kmeans_result, data = final_df)
```

```{r}
set.seed(123)  # Pour la reproductibilité
k2 <- kmeans(final_df, centers = 2, nstart = 25)
k3 <- kmeans(final_df, centers = 3, nstart = 25)
k5 <- kmeans(final_df, centers = 5, nstart = 25)

# plots to compare
p1 <- fviz_cluster(k2, geom = "point", data = final_df) + ggtitle("k = 2")
p2 <- fviz_cluster(k3, geom = "point",  data = final_df) + ggtitle("k = 3")
p3 <- fviz_cluster(k5, geom = "point",  data = final_df) + ggtitle("k = 5")
p4 <- fviz_cluster(kmeans_result, geom = "point",  data = final_df) + ggtitle("k = 4")

library(gridExtra)
grid.arrange(p1, p2, p3,p4, nrow = 2)
```

Conclusion:
Avec k = 2, les groupes sont trop larges, ne captant pas toute la diversité des individus.
k = 3 semble fournir un bon compromis entre complexité et interprétabilité.
k = 4 offre une segmentation plus détaillée, potentiellement utile pour des analyses plus fines.
k = 5 commence à fragmenter excessivement les données, ce qui pourrait nuire à la clarté des résultats.

Globalement, k = 3 ou k = 4 semblent être des choix raisonnables pour capturer la structure des données tout en maintenant une bonne interprétabilité


## Interprétation des résultats


```{r}
# Ajouter la colonne de cluster 
df$cluster <- factor(kmeans_result$cluster)
```

```{r}
# Liste des variables quantitatives à visualiser (en excluant la colonne 'cluster')
liste_variable_quanti <- c("PI", "Cadres", "Agri", "Employe", "Artisant", "Ouvrier", "TxPauv", "Salairemoy", "HLM", "NonDiplome", "txcho", "txabs")

# Pour chaque variable quantitative, créer un boxplot par rapport à cluster
for (col in liste_variable_quanti) {
  p <- ggplot(df, aes(x = cluster, y = .data[[col]], fill = cluster)) +
    geom_boxplot() +
    scale_fill_brewer(palette = "Set1") +  # Utiliser une palette de couleurs
    labs(title = paste("Boxplot de", col, "par cluster"), x = "Cluster", y = col) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),  # Incliner le texte de l'axe X
          plot.title = element_text(hjust = 0.5))  # Centrer le titre

  # Afficher le boxplot
  print(p)
}
```



```{r}
# Calculer les moyennes des variables quantitatives par cluster
moyennes_par_cluster <- df %>%
  group_by(cluster) %>%
  summarise(across(all_of(liste_variable_quanti), mean, na.rm = TRUE))

# Afficher les moyennes directement, car les valeurs sont déjà en pourcentage
for (i in 1:nrow(moyennes_par_cluster)) {
  cat("Cluster", moyennes_par_cluster$cluster[i], ":\n")
  cat(paste(names(moyennes_par_cluster)[-1], ":",
            round(moyennes_par_cluster[i, -1], 2), "%", collapse = ", "), "\n\n")
}
```

```{r}
# Charger le package
library(kableExtra)

# Calculer les moyennes des variables quantitatives par cluster
moyennes_par_cluster <- df %>%
  group_by(cluster) %>%
  summarise(across(all_of(liste_variable_quanti), mean, na.rm = TRUE))

# Créer un tableau formaté
kbl(moyennes_par_cluster, caption = "Moyenne des variables quantitatives par cluster (%)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```



```{r}
# Calculer les moyennes des variables quantitatives par cluster
moyennes_par_cluster <- df %>%
  group_by(cluster) %>%
  summarise(across(all_of(liste_variable_quanti), mean, na.rm = TRUE)) %>%
  pivot_longer(cols = -cluster, names_to = "variable", values_to = "mean_value")
```



```{r}
library(RColorBrewer)

# Créer un graphique en barres pour visualiser les moyennes par cluster
ggplot(moyennes_par_cluster, aes(x = reorder(variable, mean_value), y = mean_value, fill = variable)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Moyennes des variables quantitatives par cluster", x = "Variable", y = "Moyenne (%)") +
  theme_minimal() +
  scale_fill_brewer(palette = "Set3") +  # Utiliser une palette avec des couleurs adaptées pour plusieurs variables
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Incliner les noms des variables
  facet_wrap(~ cluster, scales = "free")  # Utiliser 'scales = "free"' pour permettre une échelle libre par cluster

```



Interprétation générale :
Cluster 2 semble représenter une population plus qualifiée avec des niveaux socio-économiques plus élevés (plus de cadres, salaire moyen plus élevé, faible taux de chômage, moins de non-diplômés), et un taux d'abstention plus faible.
Clusters 1 et 3 ont une proportion plus élevée d'ouvriers, d'employés, et de non-diplômés, des salaires plus bas et des taux de chômage plus élevés. Cela pourrait expliquer les taux d'abstention plus élevés observés dans ces clusters, surtout pour cluster 1.
Cluster 4 présente un profil intermédiaire avec une part relativement élevée de professions intermédiaires (PI), d'employés et de cadres, et des conditions socio-économiques modérées.

Synthèse :
Le Cluster 2 se démarque par des conditions socio-économiques favorables (faible pauvreté, chômage bas, et salaires élevés), et un faible taux d'abstention, tandis que les Clusters 1 et 3 montrent des populations plus vulnérables avec un taux d'abstention plus élevé. 


```{r}
# Créer des catégories basées sur des bornes ajustées pour équilibrer les groupes
df$groupe_abstention <- cut(df$txabs,
                                  breaks = quantile(df$txabs, probs = seq(0, 1, by = 1/3)),  # Tertiles
                                  labels = c("Faible", "Moyen", "Fort"))

# Vérifier la répartition des groupes
table(df$groupe_abstention)

# Afficher les premières lignes pour vérifier les résultats
head(df)
```




```{r}
ggplot(df, aes(x = factor(cluster), fill = groupe_abstention)) +
    geom_bar(position = "dodge") +
    scale_fill_brewer(palette = "Set2") +  # Utiliser une palette de couleurs
    labs(title = "Répartition du taux d'abstention par cluster",
         x = "Cluster",
         y = "Nombre de statuts") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Incliner le texte de l'axe X
```

```{r}
df_groupe <- df %>%
  group_by(cluster, groupe_abstention) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(cluster) %>%
  mutate(freq = count / sum(count)) %>%
  ungroup()
df_groupe



ggplot(df_groupe, aes(x = factor(cluster), y = freq, fill = groupe_abstention)) +
  geom_bar(stat = "identity", position = "fill") +
  geom_text(aes(label = scales::percent(freq, accuracy = 1)), 
            position = position_fill(vjust = 0.5), 
            size = 3, 
            color = "black") +
  scale_fill_brewer(palette = "Set2") +  # Utiliser une palette de couleurs
  labs(title = "Répartition proportionnelle du taux d'abstention par cluster",
       x = "Cluster",
       y = "Proportion (%)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Incliner le texte de l'axe X
```



Conclusion :
Le Cluster 1 est dominé par une forte abstention, suggérant des facteurs socio-économiques défavorables.
Le Cluster 2 a une forte proportion d'individus avec une faible abstention, ce qui pourrait indiquer une population plus engagée politiquement ou ayant des conditions socio-économiques favorables.
Les Clusters 3 et 4 montrent une répartition plus équilibrée, mais avec une légère tendance vers des taux d'abstention moyens ou élevés, particulièrement dans le Cluster 4.

Cette analyse suggère que les comportements d'abstention sont étroitement liés à des facteurs socio-économiques, avec des clusters plus défavorisés affichant des taux d'abstention plus élevés.




## Interprétation avec 3 clusters

```{r}
df$cluster3 <- factor(k3$cluster)
```

```{r}
# Pour chaque variable quantitative, créer un boxplot par rapport à cluster
for (col in liste_variable_quanti) {
  p <- ggplot(df, aes(x = cluster3, y = .data[[col]], fill = cluster3)) +
    geom_boxplot() +
    scale_fill_brewer(palette = "Set1") +  # Utiliser une palette de couleurs
    labs(title = paste("Boxplot de", col, "par cluster3"), x = "Cluster", y = col) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),  # Incliner le texte de l'axe X
          plot.title = element_text(hjust = 0.5))  # Centrer le titre

  # Afficher le boxplot
  print(p)
}
```



```{r}
# Charger le package
library(kableExtra)

# Calculer les moyennes des variables quantitatives par cluster
moyennes_par_cluster <- df %>%
  group_by(cluster3) %>%
  summarise(across(all_of(liste_variable_quanti), mean, na.rm = TRUE))

# Créer un tableau formaté
kbl(moyennes_par_cluster, caption = "Moyenne des variables quantitatives par cluster (%)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```


```{r}
# Calculer les moyennes des variables quantitatives par cluster pour 3 clusters
moyennes_par_cluster_3 <- df %>%
  filter(cluster %in% c(1, 2, 3)) %>%  # S'assurer qu'on ne prend que les clusters 1, 2, 3
  group_by(cluster) %>%
  summarise(across(all_of(liste_variable_quanti), mean, na.rm = TRUE)) %>%
  pivot_longer(cols = -cluster, names_to = "variable", values_to = "mean_value")

library(RColorBrewer)

# Créer un graphique en barres pour visualiser les moyennes par cluster
ggplot(moyennes_par_cluster_3, aes(x = reorder(variable, mean_value), y = mean_value, fill = variable)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Moyennes des variables quantitatives par cluster (3 clusters)", 
       x = "Variable", y = "Moyenne (%)") +
  theme_minimal() +
  scale_fill_brewer(palette = "Set3") +  # Utiliser une palette avec des couleurs adaptées pour plusieurs variables
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Incliner les noms des variables pour une meilleure lisibilité
  facet_wrap(~ cluster, scales = "free")  # Créer un graphique distinct par cluster avec des échelles libres

```


Synthèse :
Cluster 1 représente un profil mixte avec une forte proportion d'employés et de non dipolmé, ainsi qu'un taux d'abstention légèrement élevé.
Cluster 2 est marqué par une prédominance d'ouvriers, d'agriculteurs et de non diplomés par rappot au autres clusters, un taux de pauvreté et de chômage plus élevé, ainsi qu'un niveau d'abstention modéré.
Cluster 3 regroupe des départements à forte proportion de cadres, des salaires moyens plus élevés et des taux d'abstention les plus bas, suggérant une population plus urbanisée et économiquement favorisée.

Cette analyse montre des différences significatives entre les clusters, suggérant que les caractéristiques socio-économiques influencent le taux d'abstention, notamment en fonction de la répartition des catégories professionnelles, des niveaux de pauvreté et de diplôme.


```{r}
df_groupe <- df %>%
  group_by(cluster3, groupe_abstention) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(cluster3) %>%
  mutate(freq = count / sum(count)) %>%
  ungroup()
df_groupe



ggplot(df_groupe, aes(x = factor(cluster3), y = freq, fill = groupe_abstention)) +
  geom_bar(stat = "identity", position = "fill") +
  geom_text(aes(label = scales::percent(freq, accuracy = 1)), 
            position = position_fill(vjust = 0.5), 
            size = 3, 
            color = "black") +
  scale_fill_brewer(palette = "Set2") +  # Utiliser une palette de couleurs
  labs(title = "Répartition proportionnelle du taux d'abstention par cluster",
       x = "Cluster",
       y = "Proportion (%)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Incliner le texte de l'axe X
```

Conclusion :
Cluster 1 présente une répartition assez équilibrée entre les différents niveaux d'abstention, avec une tendance plus marquée vers la forte abstention (42%).
Cluster 2 montre un profil mixte avec une légère préférence pour les départements à faible abstention (38%), mais une présence notable de départements à forte abstention (29%).
Cluster 3 est clairement dominé par les départements avec un faible taux d'abstention (75%), suggérant une participation électorale beaucoup plus importante dans ces départements.

Ces différences entre les clusters soulignent l'importance des caractéristiques socio-économiques dans l'engagement électoral des départements.



### Conclusion générale

La segmentation des départements en fonction de leurs caractéristiques socio-économiques montre clairement que le taux d'abstention est étroitement lié à des facteurs le niveau de diplôme, et la répartition des catégories professionnelles. Plus un département est économiquement favorisé (présence de cadres, salaires moyens plus élevés), plus le taux de participation électorale est élevé.

Recommandations:

Pour améliorer la participation électorale dans les zones à forte abstention :

- Cibler les zones les plus défavorisées : Les clusters avec une faible proportions de cadres affichent des taux d'abstention élevés. Des campagnes spécifiques visant ces populations, avec un message clair sur l'importance de la participation électorale, pourraient être efficaces.

- Renforcer l'éducation civique : Dans les départements où le taux de non-diplômés est élevé, des programmes éducatifs ou des campagnes de sensibilisation pourraient contribuer à une meilleure compréhension des enjeux électoraux.















